%%
\newif\ifDraft
\Drafttrue % comment this out for submission

\documentclass[sigconf,anonymous,review,balance=false]{acmart}
\usepackage{popets}

% Copyright
\setcopyright{popets}
\copyrightyear{YYYY}

% Issue info
\acmYear{YYYY}
\acmVolume{YYYY}
\acmNumber{X}
\acmDOI{XXXXXXX.XXXXXXX}
\acmISBN{}
\acmConference{Proceedings on Privacy Enhancing Technologies}
\settopmatter{printacmref=false,printccs=false,printfolios=true}

\input{sty/packages.tex}  %<-------------- Add new packages here
\input{sty/macros.tex}
\input{sty/notation.tex}

%DIF UNDERLINE PREAMBLE %DIF PREAMBLE

\RequirePackage[normalem]{ulem} %DIF PREAMBLE

\RequirePackage{color}\definecolor{RED}{rgb}{1,0,0}\definecolor{BLUE}{rgb}{0,0,1} %DIF PREAMBLE

\providecommand{\DIFadd}[1]{{\protect\color{blue}\uwave{#1}}} %DIF PREAMBLE

\providecommand{\DIFdel}[1]{{\protect\color{red}\sout{#1}}}                      %DIF PREAMBLE

%DIF SAFE PREAMBLE %DIF PREAMBLE

\providecommand{\DIFaddbegin}{} %DIF PREAMBLE

\providecommand{\DIFaddend}{} %DIF PREAMBLE

\providecommand{\DIFdelbegin}{} %DIF PREAMBLE

\providecommand{\DIFdelend}{} %DIF PREAMBLE

%DIF FLOATSAFE PREAMBLE %DIF PREAMBLE

\providecommand{\DIFaddFL}[1]{\DIFadd{#1}} %DIF PREAMBLE

\providecommand{\DIFdelFL}[1]{\DIFdel{#1}} %DIF PREAMBLE

\providecommand{\DIFaddbeginFL}{} %DIF PREAMBLE

\providecommand{\DIFaddendFL}{} %DIF PREAMBLE

\providecommand{\DIFdelbeginFL}{} %DIF PREAMBLE

\providecommand{\DIFdelendFL}{} %DIF PREAMBLE

%DIF END PREAMBLE EXTENSION ADDED BY LATEXDIFF
\begin{document}
	
	%%
	%% The "title" command has an optional parameter,
	%% allowing the author to define a "short title" to be used in page headers.
	\title{How to cut cake securely and have it too}
	
	%%%%%%%%%%%%%%%% Authors' Info %%%%%%%%%%%%%%%%%
	%%
	%% The "author" command and its associated commands are used to define
	%% the authors and their affiliations.
	
	%\author{Ben Trovato}
	%\orcid{1234-5678-9012}
	%\affiliation{%
		%  \institution{Institute for Clarity in Documentation}
		%  \city{Dublin}
		%  \state{Ohio}
		%  \country{USA}}
	%\email{trovato@corporation.com}
	
	%\author{Lars Th{\o}rv{\"a}ld}
	%\affiliation{%
		%  \institution{The Th{\o}rv{\"a}ld Group}
		%  \city{Hekla}
		%  \country{Iceland}}
	%\email{larst@affiliation.org}
	
	%\author{Valerie B\'eranger}
	%\affiliation{%
		%  \institution{Inria Paris-Rocquencourt}
		%  \city{Rocquencourt}
		%  \country{France}
		%}
	%\email{valerie@affiliation.org}
	
	%\author{Aparna Patel}
	%\affiliation{%
		% \institution{Rajiv Gandhi University}
		% \city{Doimukh}
		% \state{Arunachal Pradesh}
		% \country{India}}
	%\email{aparnap@rgu.ac.in}
	
	%\author{Huifen Chan}
	%\affiliation{%
		%  \institution{Tsinghua University}
		%  \city{Haidian Qu}
		%  \state{Beijing Shi}
		%  \country{China}}
	%\email{huifenchen@tsinghua.edu.cn}
	
	%\author{T. Charles Palmer}
	%\affiliation{%
		%  \institution{Palmer Research Laboratories}
		%  \city{San Antonio}
		%  \state{Texas}
		%  \country{USA}}
	%\email{tcpalmer@prl.com}
	
	%\author{John Arthur Smith}
	%\affiliation{%
		%  \institution{The Th{\o}rv{\"a}ld Group}
		%  \city{Hekla}
		%  \country{Iceland}}
	%\email{jsmith@affiliation.org}
	
	%\author{Julius P. L. Kumquat}
	%\affiliation{%
		%  \institution{The Kumquat Consortium}
		%  \city{New York}
		%  \country{USA}}
	%\email{jplkumquat@consortium.net}
	
	%%
	%% By default, the full list of authors will be used in the page
	%% headers. Often, this list is too long, and will overlap
	%% other information printed in the page headers. This command allows
	%% the author to define a more concise list
	%% of authors' names for this purpose.
	
	%\renewcommand{\shortauthors}{Trovato et al.}
	
	%%
	%% The abstract is a short summary of the work to be presented in the
	%% article.

	\begin{abstract}
		In this work, we construct a secure protocol for the fair division of a certain divisible good -- also known as the cake division problem. We make use of the \emph{Lone divider algorithm} for this purpose. Our protocol ensures fairness as per individual valuations of parties and confidentiality of these  valuations. We prove the fairness and security of our protocol in a malicious adversarial setting. \\
		Our protocol is implemented using open source cryptographic constructs. Running our fair division protocol on commodity hardware with $15$ bidders completes in $1.26$sec and has total communication of $0.77$MB whereas for the same setting,  semi-honest version of protocol takes $2.11$ sec with $6.09$MB of communication.
	\end{abstract}

 %%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%\begin{CCSXML}
%<ccs2012>
% <concept>
%  <concept_id>00000000.0000000.0000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>500</concept_significance>
% </concept>
% <concept>
%  <concept_id>00000000.00000000.00000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>300</concept_significance>
 %</concept>
% <concept>
%  <concept_id>00000000.00000000.00000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
% <concept>
%  <concept_id>00000000.00000000.00000000</concept_id>
%  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
	\keywords{fair-division, cake-cutting, lone-divider-method}
	
	
	\maketitle
	
	%\input{intro.tex}
	\section{Introduction} 
	
	
	
	
	\paragraph{Our contribution.}
	
	
	\paragraph{Outline.} The rest of the paper is organized as follows. Related works is presented in Section~\ref{sec-rel-work} where we provide a survey of prior works related to rational security and auctions. Section~\ref{techoverview} presents an overview of our work, specifically highlighting the challenges and design decisions for SPA protocol. Preliminaries are described in Section~\ref{sec-prelim}. Section~\ref{sec-rational-security} describes the rational security model used in our work. Section~\ref{sec-proto-spec-spa} provides a detailed description of the protocol divided into multiple phases. We analyze the strategy space available to rational parties along with security proofs in Section~\ref{sec-rational-strtg}. For each strategy, we argue why it is rational for parties to stay honest. Lastly, we summarize the experimental results in Section~\ref{sec-expt} and conclude.
	
	
	%\input{related-work}
	\subsection{Related work}\label{sec-rel-work} 
	
	\paragraph{Game theoretic tools for cryptography.} The intersection of game theory and cryptography has attracted interest from the cryptographic research community for the past two decades. The work of Dodis, Halevi and Rabin~\cite{C:DodHalRab00} initiated a line of work capturing notions of incentives in cryptographic definitions. The work of Halpern and Teague~\cite{STOC:HalTea04} considered secret sharing and secure computation in the rational setting. They define a solution concept that is a variant of Nash equilibrium. Subsequent works define further variants of equilibrium, like computational versions and for modelling collusion~\cite{PODC:ADGH06,SCN:GorKat06,PODC:Halpern08,TCC:KolNao08,ITCS:HalPas10}. A noteworthy contribution in rational cryptography is the Rational Protocol Design (RPD) framework introduced by Garay, Katz, Maurer, Tackmann and Zikas~\cite{FOCS:GKMTZ13} and employed subsequently in~\cite{PODC:GKTZ15,EC:BGMTZ18}.  RPD models the  protocol design as a two party game between a protocol designer and an external attacker, where the attacker's goal is to break security properties, and the goal of the protocol designer is to prevent the attacker from succeeding. Bi{\c{c}}er, Yildiz and K{\"u}p{\c{c}}{\"u}~\cite{byk21} make use of \emph{Weakly dominant strategy} for coalitions in their work  to develop the notion of \emph{m-stability} which offers threshold security against a coalition of size $m$. 
	
	\paragraph{Auctions.}
	The work of Miltersen, Nielsen and Triandopoulos \cite{C:MilNieTri09} defined a rational security framework for first price auctions wherein the bidders care more about the monetary payoffs  than learning about bids of other parties. Important contributions of their work are a novel notion of \emph{information utility} and \textit{Privacy enhanced computational Nash Equilibrium} for modeling rational security. They use generic MPC protocols to run the first price  auction and show that their protocol achieves this equilibrium. However, Nash equilibrium ensures honesty for a rational party only when all other parties are also honest. Instead, we make use of stronger notion of dominant strategy equilibrium wherein honest strategy is the best response irrespective of others' strategic choices. Moreover, our solution concept also guarantees privacy by exhibiting a simulator.\\
	SEAL~\cite{seal19} was a work by Bag, Hao, Shahandashti and Ray, who propose auction protocols without needing auctioneers. They make use of \emph{Anonymous Veto Protocol} (AVP)~\cite{avp06}. FAST~\cite{fast21} is a similar protocol by David, Gentile and Pourpouneh, which also uses AVP. However, both these works have a non-trivial leakage. Their first price auction protocol leaks first few bits of second highest bid value and their second price auction protocol leaks first few bits of highest bid value. Ganesh, Kanukurthi and Shankar have introduced a first price auction protocol without requiring auctioneers but ensuring total privacy in a rational setting in~\cite{gks22}.   
	
	
	
	
	%\input{tech-overview.tex}
	\subsection{Technical overview}\label{techoverview}
	\paragraph{Threat model.} 
	In our rational security model, every party may deviate from the protocol to meet their most desired goal of winning the auction. Other considerations, such as learning information about other parties, do exist but are secondary. Parties can either act in their individual capacity or form strategic coalitions for enhancing their gains. The utility function captures these considerations. %At CCS 2022, Ganesh, Kanukurthi and Shankar~\cite{gks22} built a protocol for first price auctions secure in the rational security model. The authors show that their protocol achieves \emph{privacy enhanced weakly dominant strategy equilibrium}. At a high level, this involves two steps: a) one needs to show that following the protocol is indeed a (weakly) dominant strategy equilibrium for the parties and b) use the simulation paradigm to argue privacy when parties are honest. We show that our second price auction protocol satisfies this equilibrium.
	
		
	\paragraph{Security.} 
	In order to argue security, we note that a rational party sees value in a) increasing its monetary utility by winning the auction and b) learning information about other players' inputs. To capture these, we use monetary and information utilities (similar to earlier works in~\cite{C:MilNieTri09,gks22}). We also use the notion of \emph{Privacy Enhanced Computational Dominant Strategy Equilibrium} introduced in ~\cite{gks22} for analyzing the privacy concerns of rational parties. This equilibrium states that as long as parties value monetary utility much more than information utility, they have no incentive to deviate from the protocol. Then, for parties that do not deviate from the protocol, we argue privacy using the simulation paradigm.

	%\input{prelim.tex}
	\begin{comment}
		
	\end{comment}
	
	\section{Preliminaries}\label{sec-prelim}
	\paragraph{Notation.}
	We denote the security parameter by $\lambda$. Let $\grp$ be the description of the group of prime order $q$, and with generators $g,h$.
	A function $\mathsf{negl}$ is said to be negligible if $\negl(n) < 1/p(n)$ for all positive polynomial functions $p(\cdot)$ and for all $n > n_0$ for some $n_0 \in \mathbb{N}$. 
	We denote \emph{Probabilistic Polynomial Time} by PPT. We also use $\approx_c$ to denote computational indistinguishability between two probability distributions.
	
	
	\subsection{Building blocks} Here we describe some key building blocks that are used in our protocol.
	
	\begin{definition}[Commitment scheme]
		Let $\sfm, \sfc, \sfr$ denote the message space, commitment space and randomness space respectively.\\
		A commitment scheme consists of a tuple ($\mathsf{Setup}, \com,\mathsf{Open}$) of PPT algorithms where:
		\begin{itemize}
			\item $\mathsf{Setup}(1^\lambda) \rightarrow \mathsf{pp}$ generates public parameters $\mathsf{pp}$.
			\item $\com(m,r) \rightarrow c$ takes as input $\mathsf{pp}$ (implicitly), a message $m \in \sfm$, randomness $r \in \sfr$ and outputs a commitment $c \in \sfc$. 
			\item $\mathsf{Open}(c, m, r) \rightarrow B \in \{0,1\}$ checks if the commitment $c$ opens to the message $m$, given randomness $r$. It outputs $1$ if the opening is acceptable and $0$ if the opening is rejected.
		\end{itemize}
	\end{definition}	
	
	
	The security of a commitment scheme guarantees two properties: \emph{hiding} and \emph{binding}. Informally, the hiding property guarantees that for any two messages $m_0$ and $m_1$, no PPT algorithm can distinguish between commitments to $m_0$ and $m_1$. The binding property guarantees that no PPT algorithm can open a commitment to two different messages. 


	\paragraph{Oblivious transfer.} \label{proto-ot}
	Oblivious Transfer (OT) is a two-party  protocol with sender $S$ having two secret messages and receiver $R$ with a single choice bit. The goal of the protocol is for $R$ to learn the message of its choice without learning about the other message from the sender. In addition, OT protocol demands that $S$ does not learn about the choice exercised by $R$. We make use of OT for securely sharing messages between parties. Let $\sfm, \sfr$ be the message space and randomness space, respectively. An OT protocol proceeds as follows for two PPT parties, $R$ and $S$:
	\begin{itemize}
		\item $\mathsf{OT.R}_1(\alpha,\beta) \rightarrow (\otr^1, state)$ is invoked by $R$ with inputs: choice bit $\alpha \in \{0,1\}$, randomness $\beta \in \sfr$. $\otr^1$ is the first message sent by $R$ to $S$. $state$ is the internal state of $R$. 
		\item $\mathsf{OT.S}(\otr^1,M^{(0)},M^{(1)},\gamma) \rightarrow \ots_{S,R}$ takes $\otr^1$, messages $M^{(0)},M^{(1)} \in \mathsf{M}$, randomness $\gamma \in \sfr$ and outputs message $\ots_{S,R}$ to be sent by $S$ to $R$.
		\item $\mathsf{OT.R}_2(\ots_{S,R}, state) \rightarrow M^{(\alpha)}$ Invoked by $R$ with $\ots_{S,R}$ from $S$ and internal state to retrieve the message $M^{(\alpha)}$. 
	\end{itemize}
	The security of OT protocol ensures that the receiver does not learn about $M^{(1-\alpha)}$ and the sender does not learn about $\alpha$. 
	
	
	\paragraph{Bulletin board.}
	The \emph{Bulletin Board} (BB) is an abstraction for an authenticated broadcast channel with memory. We assume the  existence of such a broadcast channel for our protocol. We do acknowledge that implementation of such broadcast channels can have different threat models than ours. However, in this work we do not concern ourselves with the problem of handling broadcast in a rational setting, which is of independent interest and can be considered for future works. In our protocol, parties can write messages on to the BB for public consumption. The BB is expected to satisfy the following properties:
	(i) Every message  written on the BB is associated with a unique party and is readable by all other parties.
	(ii) The messages written on BB are immutable. 
	
	A BB can be realized through a public chat-room, shared web-page, or even a private blockchain. Our protocol does not rely upon any specific realization of BB.
	
	\subsection{Fairness notions}
	We now describe some game theoretic notations and definitions used in our work. We assume that there are $n$ parties $(P_1,\ldots,P_n)$ participating in a game. 
	
	\begin{definition}[Normal Form Game~\cite{TCC:Katz08b}] 
		A normal form game is a tuple $\left\{\{\Gamma_i\}_{i=1}^n, \{U_i\}_{i=1}^n \right\}$ where for each party $P_i$, a space of possible actions $\Gamma_i$ along with a utility function $U_i$ are specified. 
	\end{definition}
	
	Each party $P_i$ can be associated with certain strategy $\pi_i \in \strspc$ where $\strspc$ is a strategy space available for the parties to choose their strategies from, while playing the game. $\pi_i$ is essentially an algorithm that takes as input the private inputs of $P_i$, the current state of the game and outputs the action $s_i \in \Gamma_i$ to be taken by $P_i$ where $\Gamma_i$ is the space of actions available for party $P_i$ during the game. We denote the outcome of the game using the strategy profile of parties $(\pi_i,\pi_{-i})$ where $\pi_{-i} = (\pi_1, \ldots, \pi_{i-1}, \pi_{i+1}, \ldots, \pi_n)$. We also assign utility functions $U_i(\pi_i,\pi_{-i})$ to each party $P_i$. These functions represent the perceived utility of different outcomes of the game for the party. We say that a party $P_i$ \emph{prefers} a certain outcome $(\pi_i, \pi_{-i})$ over another outcome $(\pi_i', \pi_{-i})$ if and only if $U_i(\pi_i', \pi_{-i}) < U_i(\pi_i, \pi_{-i})$.
	\begin{definition} [Dominant Strategy~\cite{TCC:Katz08b}]
		Given a normal form game: $\left \{\{\Gamma_i\}_{i=1}^n, \{U_i\}_{i=1}^n\right \}$
		we say, $\pi_i \in \strspc$ is a \emph{Dominant Strategy} for $P_i$ if $U_i(\pi_i', \mathbf{\pi}_{-i}) < U_i(\pi_i, \mathbf{\pi}_{-i})$, $\forall \pi_i' (\neq \pi_i )\in \strspc $ and $\forall \mathbf{\pi}_{-i} \in \strspc^{n-1}$. 
	\end{definition}
	Such a strategy $\pi_i$ guarantees that a party $P_i$ can accrue the best utility among all strategies available to it.
	In the above case, $\pi_i'$ is also termed as \emph{Dominated Strategy}. The parties typically avoid dominated strategies, whereas dominant strategies are pursued. We also have a weaker notion of \emph{Dominant Strategy} known as \emph{Weakly Dominant Strategy}.  
	
	\begin{definition} [Weakly Dominant Strategy~\cite{TCC:Katz08b}] \label{def-wdse} 
		Given a normal form game: $\left \{\{\Gamma_i\}_{i=1}^n, \{U_i\}_{i=1}^n\right \}$
		we say $\pi_i \in \strspc$ is a \emph{Weakly Dominant Strategy} for $P_i$  if $U_i(\pi_i', \pi_{-i}) \leq U_i(\pi_i, \pi_{-i}), \forall  \pi_i'(\neq \pi_i) \in \strspc ,  \forall \pi_{-i} \in \strspc^{n-1}$. 
		In addition,  $\forall \pi_i' (\neq \pi_i)$ there exists some $\pi_{-i} \in \strspc^{n-1}$ such that $U_i(\pi_i', \pi_{-i}) < U_i(\pi_i, \pi_{-i})$. 
	\end{definition}
	
	\begin{definition}[Weakly Dominant Strategy Equilibrium (W-DSE)~\cite{narahari14}]\label{def-wdseqbm} 
		For a normal form game $\left \{\{\Gamma_i\}_{i=1}^n, \{U_i\}_{i=1}^n \right \}$, the strategy profile $\mathbf{\pi} = (\pi_1, \ldots, \pi_n) \in \strspc^n$ is a \emph{Weakly Dominant Strategy Equilibrium} if $\forall P_i,  i \in [n]$, $\pi_i$ is a \emph{Weakly Dominant Strategy} for party $P_i$. 
	\end{definition}
	
	A \emph{Dominant Strategy Equilibrium}, whenever it exists, guarantees that every party has a unique \emph{Dominant Strategy} available to it. Thus, each party can realize maximum utility by adopting its \emph{Dominant Strategy}. Since such a strategy becomes a preferred choice for every party, irrespective of the strategic choices of other parties in the game, the chosen strategy profile is an equilibrium.  
	
	
\subsection{Valuation functions}
  We assume there are $n$ parties that participate in the fair division protocol, denoted by $P_1, P_2, \dots, P_n$. Each party $P_i$ has a valuation function $\val_i$.
 
	%\input{proto-spec}
	\section{Our protocol}\label{sec-proto-spec-spa}
	We now present a description of our fair division protocol $\Pi$ which guarantees full privacy in the presence of malicious adversaries.
	
	\subsection{Notation}
	We use as building blocks a maliciously secure OT protocol $\Pi_{OT}$, a secure commitment scheme $\com$ an integer comparison protocol $\Pi_{IC}$ and non-interactive zero-knowledge (NIZK) proofs. We use a group $\grp$ of prime order $q$ where the DDH assumption holds. 
	

	The protocol uses a Bulletin Board (BB) for all communication. We use the notation $A_{ij,k}$ to denote the message or random value $A$ generated by the party $P_i$ while interacting with the party $P_k$ during the round $j$. We use $[0]_{ij}, [1]_{ij}$ to denote encoding of bits $0$ and $1$ respectively by $P_i$ during round $j$. $\smpl$ denotes uniform sampling from a certain distribution, $\pay$ denotes payment and $\bbwrite$ denotes writing to BB.


\subsection{Construction} \label{proto-spec-spa}
We describe our FD protocol as a set of algorithms. During setup phase (Algorithm~\ref{alg:setup}), one of the parties $P_d$ is elected as the \emph{lone divider} who divides the given cake $C$ into $n$ parts which are all equal as per its valuation function $\val_d$. Each party evaluates these parts. Then parties allocate their secret keys, construct commitments to their valuations and publish the public keys and commitments to the BB.
\begin{algorithm}[ht]
\caption{Setup}
\label{alg:setup}
\begin{algorithmic}[1]
	\State Each $P_i$ is initialized: $P_i(v_i)$ 
    \State $\mathsf{pp} =  (\grp, q, g,\tau, C)$ // Receive public parameters
    \State Elect one of the parties $P_d$ as the \emph{divider}.
    \State $P_d$ divides $C$ into $n$ parts such that $\val_d(C_i) = \val_d(C)/n, \forall i \in [n]$.
    \State $BB \bbwrite C_i$  
    \For{$i = 1$ to $n$} 
    	\For{$j = 1$ to $n$} 
    		\State Compute $V_{ij} = \val_i(C_j)$ for all $j \in [n]$
    		\State $a_{ij} \smpl \zq$, $c_{ij} = \com(V_{ij}, a_{ij})$     	                   
        	\State $x_{ij}, r_{ij} \smpl \zq$ 
        	\State // Secret keys: $x_{ij}$ for encoding $0$ and $r_{ij}$ for encoding $1$
        	\State $X_{ij} = g^{x_{ij}}$ // Public key
                \State $BB \bbwrite (X_{ij}, c_{ij})$
       		
        \EndFor
    \EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Encoding values}
\label{alg:encode}
\begin{algorithmic}[1]
	\For{$i = 1$ to $n$} 
        \For{$j = 1$ to $n$}     
            \State Copy $X_{kj}$ for all $i \neq k \in [n]$
            \State Compute $Y_{ij} = 
            \dfrac{\prod_{k=1}^{i-1} X_{kj}}{\prod_{k=i+1}^n X_{kj} }$
            \If{$V_{ij} \geq \dfrac{\val_i(C)}{n}$}
                \State $[V_{ij}] = g^{r_{ij}}$
            \Else
                \State $[V_{ij}] = Y_{ij}^{x_{ij}}$
            \EndIf
            \State $BB \bbwrite [V_{ij}]$
        \EndFor    
    \EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Check feasibility}
\label{alg:feas}
\begin{algorithmic}[1]
	\For{$j = 1$ to $n$} 
        \For{$i = 1$ to $n$}     
            \State Copy $[V_{ij}]$ from $BB$
            \State Compute $B_{j} = 
            \prod_{k=1}^{n} [V_{kj}]$
        \EndFor    
    \EndFor
    \State Compute $m = |\{k \vert k \in [n], B_k = 1\}|$
    \If{$m > 1$}
        \State Allocate one of $C_k$ such that, $B_k = 1$ to $P_d$
        \State Return \textsc{not-feasible}
    \EndIf
    \State Return \textsc{feasible}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Find highest bidder}
\label{alg:highest bidder}
\begin{algorithmic}[1]
	\For{$j = 1$ to $n$} 
        \State $M_j = \argmax_i(v_{ij})$
        \State Allocate $c_j$ to $P_{M_j}$
    \EndFor
\end{algorithmic}
\end{algorithm}



Auction phase (Algorithm~\ref{alg:auction}) runs for $l$ rounds. During each round, parties use ABP to determine their contribution bit for the round and exchange encoded bits through OT. At the end of each round, parties compute the output bit.

\begin{algorithm}[ht]
\caption{Auction Phase}
\label{alg:auction}
\begin{algorithmic}[1]%\vspace{-0.4cm}

    \State Each $P_i$ receiving from $P_k$ through OT during round $j$:
        \If{$state_i = active$} // $P_i$ is still in race
            \State $d_{ij} = b_{ij}$
        \EndIf
        \If{$state_i = winner$} 
            \State $d_{ij} = 1$  
        \EndIf

        \If{$state_i = loser$} 
            \State $d_{ij} = 0$
        \EndIf
        \If{$d_{ij} = 0$}
        	\State $B_{ij} =  Y_{ij}^{x_{ij}}$ // $[0]_{ij}$
        \Else
        	\State $B_{ij} = g^{r_{ij}}$ // $[1]_{ij}$
        \EndIf

        \State {\bf OT Receiver:}$(P_i)$
        \State $\alpha_{ij,k} = d_{ij}$,\;\; $\beta_{ij,k} \smpl \sfr$
        \State $\otr_{ij,k}^1=\mathsf{OT.R}_1(\alpha_{ij,k}, \beta_{ij,k})$, \;\; $BB \bbwrite \otr_{ij,k}^1$
        \State  //Write OT receiver randomness to BB for $P_i \leftarrow P_k$
        \State {\bf OT Sender:} $(P_k)$
        \State  $M_{kj,i}^{(1)} = B_{kj}$
        \State $\omega_{kj,i} \smpl \zq$, \;\; $M_{kj,i}^{(0)} = g^{\omega_{kj,i}}$.  
        \State // $0$-Token of $P_k \rightarrow P_i$
        
        \State $\delta_{kj,i} \smpl \zq$, \;\; $\Omega_{kj,i}=\com(\omega_{kj,i}\delta_{kj,i})$, \;\; $BB \bbwrite \Omega_{kj,i}$ 
        \State // Write commitment to $0$-token to BB
        \State $\ots_{kj, i} = \mathsf{OT.S}\left(\otr_{ij,k}^1, M_{kj,i}^{(0)}, M_{kj,i}^{(1)}, \gamma_{kj,i}\smpl \sfr\right)$
        \State $BB \bbwrite \ots_{kj, i}$ // OT sender randomness of $P_k \rightarrow P_i$
        \State $P_i$ retrieves $P_k$'s message as $B_{kj,i} = \mathsf{OT.R}_2(\ots_{kj, i},\beta_{ij,k})$.
        \State {\bf DO}  $Winner\;Discovery$ (Algorithm~\ref{alg:winner-discovery})
        \State {\bf DO}  $Write\;to\;BB$ (Algorithm~\ref{alg:write-to-BB})
        \State {\bf DO}  $Cheater\;Detection$ (Algorithm~\ref{alg:cheater-detection})
        \State {\bf DO}  $Compute\;Output$ (Algorithm~\ref{alg:compute-output})
        
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[ht]

\caption{$Cheater\;Detection$}
\label{alg:cheater-detection}
\begin{algorithmic}[1]%\vspace{-0.4cm}
        \State Each $P_i$ during round $j$ with $(d_{ij} = 1)$:
        \If{$B_{kj,i} \neq B_{kj}$ }
        	\State $BB \bbwrite (\beta_{ij,k}, a_{ij},x_{ij}, r_{ij})$
        	\State // $P_i$ opens its OT randomness, commitment, and secret key for round $j$
        	\State $P_k$ forfeits deposit to $P_i$ // $P_k$ is cheater
        	\State $state_i = terminate$
        \EndIf
        \State Each $P_i$ during round $j$
        \If{Messages not received from $P_k$ within $\tau$ units}
            \State Declare timeout against $P_k$
           	\State $P_k$ forfeits deposit to honest parties // $P_k$ is cheater

            \State $state_i = terminate$
        \EndIf
        \State
\end{algorithmic}
\end{algorithm}

Each party contributing a $1$ during a round checks locally if it is the winner, as in Algorithm~\ref{alg:winner-discovery}. The winner discovery happens oblivious to other parties. 
\begin{algorithm}[ht]
\caption{$Winner\;Discovery$}
\label{alg:winner-discovery}
\begin{algorithmic}[1]%\vspace{-0.4cm}
	\State Each $P_i$ during round $j$ with $d_{ij} = 1$:
    \State $B = \prod_{k \in [n],k \neq i} B_{kj}\cdot [0]_{ij}$ \label{compute-or-of-others}
    \If{$B = 1$}
        \State $state_i = winner$
    \EndIf
\end{algorithmic}
\end{algorithm}
After a successful winner discovery, winner's behavior is different from other parties as can be seen in Algorithm~\ref{alg:write-to-BB}. \\
\begin{algorithm}[ht]
\caption{$Write\;to\;BB$}
\label{alg:write-to-BB}
\begin{algorithmic}[1]%\vspace{-0.4cm}
    \If{$state = winner$} 
	   \State // Winner $P_w$ with $(state_w = winner)$ during round $j$:
      \State $B = \prod_{k \in [n],k \neq w} B_{kj}\cdot [0]_{wj}$
      \If{$B = 1$}
        \State $BB \bbwrite [0]_{wj}$
      \Else
        \State $BB \bbwrite [1]_{wj}$
      \EndIf
    \Else // Not a winner
      \State $BB \bbwrite B_{ij}$
    \EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{$Compute\;Output$}
\label{alg:compute-output}
\begin{algorithmic}[1]%\vspace{-0.4cm}
        \State Each $P_i$ during round $j$:
        \State \quad $B = \prod_{k \in [n]} B_{kj}$
        \quad \If{$B = 1$}
        \State \quad $b_{sj} = 0$
        \Else
        \State \quad$b_{sj} = 1$
        \EndIf
        \If{$b_{sj} = 1 \land d_{ij} = 0$}
        \State  $state_i = loser$
        \EndIf
        \State After $l$ rounds, $b_s = (b_{s1}|| \cdots || b_{sl})$
\end{algorithmic}
\end{algorithm}
After $l$ rounds of auction phase, verification phase (Algorithm~\ref{alg:verification}) is initiated to check if the parties had been honest in their computation. If any cheating is detected or if there is any timeout noticed, the protocol terminates. The aborted and cheating parties lose their deposits which is redistributed among the honest parties. Honest parties get back their deposits.\\

\paragraph{Remark 1:} 
    Our protocol assumes a unique highest bidder. If there are multiple highest bidders then the computed output also happens to be the highest bid value. In such a case, we can use arbitrary tie breaking mechanisms to choose the winner. \girisha{What about winning bid? Can we make it as $1$ less than the computed value? Just to make it rational for chosen winner?} \\ 
\paragraph{Remark 2:} We would like to emphasise that the Winner resolution procedure in Algorithm~\ref{alg:verification} acts as a deterrent for any rational party from cheating.  A rational party does not use this mechanism to learn about the bid value of another. This follows from our assumption that each party values its monetary utility to be higher than the information utility. 
\begin{algorithm}[ht]
	\caption{Verification phase}
	\label{alg:verification}
	\begin{algorithmic}[1]%\vspace{-0.4cm}
		\State {\bf Winner Claim:}\label{winner-proof}
		\State For $P_w$ claiming auction, for all $j \in [l]$:
		\State \quad $BB \bbwrite (x_{wj}, r_{wj})$ \quad// Private keys used for computation
		\State
		\State {\bf Winner resolution:}\label{prf-resolve-winner} 
		\State Each $P_i$ claiming auction, for all $j \in [l]$ and $k \in [n], k \neq i$:
		\State \quad $BB \bbwrite (\beta_{ij,k}, \gamma_{ij,k})$
		\State \quad $BB \bbwrite (c_{ij}, a_{ij})$
		\State Public verification of consistency of claimant's messages
		\State
		\State {\bf Proof of correct choice bit:}			\label{prf-loser-choice-bit}

		\State Each $P_i, i \neq w$, for all $j \in [l]$ with $b_{sj} = 0$ and $k \in [n], k \neq i$:
		\State \quad$BB \bbwrite M_{kj,i}^{(0)}$ // $0$-token received from $P_k$
		\State \quad$BB \bbwrite (\omega_{ij,k}, \delta_{ij,k})$ // Commitments to $0$-tokens sent to $P_k$
		\State
		\State {\bf Proof of correct computation:}\label{proto-nizk}
		\State Each $P_i, i \neq w$, for all $j \in [l]$ with $b_{sj} = 1$:
		\State \quad $BB \bbwrite$ NIZK proof for relation in equation~\ref{rel-not-win} of Appendix ~\ref{app-nizk}.
		\State
		\State Honest parties get back their deposit.
		\State Parties failing to provide $0$-token or accepting NIZK are considered cheating and forfeit deposit, which is distributed among the honest parties.
	\end{algorithmic}
\end{algorithm}


	We show that the above protocol correctly computes the second highest bid in Appendix~\ref{proto-correctness}. In the next section, We analyze the strategies of a party participating in the protocol. We show  that the honest strategy is weakly dominant for any party $P_k$. We then prove that this protocol does not leak anything, other than the protocol output, to any party that does not deviate from the protocol in Appendix~\ref{app:privacy}. Transactions related to security deposit are handled outside the protocol (see Appendix~\ref{app-contract}).
	
	\begin{theorem}\label{thm-dom-str}
		Let  $P_i, i \in [n]$ be any PPT party participating in the second price auction protocol $\Pi$ described in Section~\ref{proto-spec-spa}. Then, assuming that the DDH assumption holds in $\grp$, $\com$ is a secure commitment scheme and $\Pi_{OT}$ is a malicious secure OT implementation, the protocol $\Pi$ is a weakly dominant strategy equilibrium as per Definition ~\ref{def-wdse}. 
	\end{theorem}

	%\input{pedse.tex}
	\subsection{Privacy enhanced rational security protocol} \label{privacy-spa-rational}
	Having established the equilibrium from Theorem~\ref{thm-dom-str}, to argue privacy, it suffices to show that nothing beyond the output is learned by parties who are non-deviating. 	For this, we use the \textit{ideal world -- real world paradigm}. First we present the description of a simulator. We would like to emphasize that due to the symmetric nature of our protocol, it suffices to show the simulator for one party which would be same for others too. We then show that the view of a party $P_k$ in a real run of the protocol is indistinguishable from the output of the simulator. We denote by $\view_k^{\Pi}$, the distribution of the view of party $P_k$ while participating in protocol $\Pi$.
	
	
	\begin{theorem}
		\label{thm-privacy-sim-rational}
		Assuming $\com$ is a secure commitment scheme, DDH assumption holds in the group $\grp$, $\Pi_{OT}$ is a semi-honest secure OT protocol and zero knowledge property holds for the NIZKs, $\Pi$ specified in Section~\ref{proto-spec-spa} securely realizes the functionality $\calf$ in the presence of non-deviating parties. 
	\end{theorem}
	We present the ideal functionality $\mathcal{F}$ and the proof in Appendix~\ref{app:privacy}.
	
	The following Theorem stating that $\Pi$ is a \emph{Privacy Enhanced Computational Dominant Strategy Equilibrium}, follows as a corollary of Theorems~\ref{thm-dom-str} and~\ref{thm-privacy-sim-rational}.
	
	\begin{theorem} \label{thm-priv-dom-str}
		Let $P_i, i \in [n]$ be rational parties with respective utility functions $(u_1, \ldots, u_n)$ as described above. Assuming $\com$ is a secure commitment scheme, DDH in group $\grp$ and $\Pi_{OT}$ is a maliciously secure OT protocol and zero knowledge property holds for the NIZKs, the protocol $\Pi$ described in Section~\ref{proto-spec-spa} is a privacy enhanced computational dominant strategy equilibrium as per Definition ~\ref{def-priv-enh-dse}.
	\end{theorem}
	
	%\input{expt.tex}
	\section{Experimental results}\label{sec-expt}
	Our protocol was implemented in C++ and executed on a single machine using Intel core i7 processor with 32GB RAM, 2.9 GHz, running Ubuntu 22.04 operating system. Each bidder is represented by a separate process. We have used the elliptic curve secp256k1 as the underlying Group from OpenSSL. NUMS implementation is used for computing the group generators. We have implemented the NIZKs required for our protocol (for relation~\ref{rel-not-win} in Appendix~\ref{app-nizk}) using the construction from \cite{cs97,fast21}. We instantiate our Oblivious Transfer with the construction in Figure $13$ of \cite{AC:CanSarWan20}. In the following, we compare our protocol's run time and communication cost with the protocols from MP-SPDZ suite ~\cite{keller20} in Table~\ref{tab-eff-comp-protocol}. For each protocol, the measurements are taken for $15$ bidders with bid value $100 \leq b < 1000$. We observe that our protocol runs 1.7X faster than the semi-honest protocol $Atlas$.
	\begin{table}[H]
		\footnotesize
		\begin{minipage}{0.45\textwidth} 
			\centering	
			\begin{tabular}{|p{1.5cm}|p{1.25cm}|p{1.1cm}|p{2.15cm}|}
				\hline
				\textbf{Protocol}  &{\bf Threat \newline model} &{\bf Run time \newline (in sec)} &{\bf Communication Complexity (in MB)}\\	
				\hline
				Our SPA Protocol &Rational &1.26  &0.779 \\
				\hline
				Atlas~\cite{C:GLOPS21} &Semi-honest  &2.11 &6.09  \\
				\hline
				Mascot~\cite{CCS:KelOrsSch16} & Malicious   &55.65 &4074.5  \\
				\hline
				Semi-BMR~\cite{bmr19} & Semi-honest   &198.77 &18462  \\
				\hline
				Real-BMR~\cite{bmr19} & Malicious   &1137.39 &109905 \\
				\hline
			\end{tabular}
			\caption{Comparison of the efficiency of protocols. }
			\label{tab-eff-comp-protocol}
		\end{minipage}
		
	\end{table}
	\begin{figure}[h]
	%	\includegraphics[scale=0.4]{../chart-1.png}
	\end{figure}
	\begin{figure}[h]
	%	\includegraphics[scale=0.4]{../chart-2.png}
		\caption{Protocol Run times vs number of bidders}
		\label{fig-perf-plot}
	\end{figure}
	
	Figure~\ref{fig-perf-plot} shows the plot of run times of various protocols for different numbers of bidders. For BMR protocols, the maximum number of bidders we could consider while running on our machine was $15$, and for Mascot, it was $35$. 
	\section{Conclusion}
	We construct a protocol for \emph{Second Price Auction} that is provably secure in the rational setting and concretely efficient. We utilize the notion of \textit{Privacy Enhanced Computational Dominant Strategy Equilibrium} to establish rational security. Our work leaves open several interesting questions about extending the protocol to other flavors of auctions, such as multi-unit auctions, analyzing other adversarial models like adaptive strategies.
	\girisha{Can we remove the conclusion. It doesn't seem to be adding much of value.}
	%\section{Appendices}

%If your work needs an appendix, add it before the
%``\verb|\end{document}|'' command at the conclusion of your source
%document.

%Start the appendix with the ``\verb|appendix|'' %command:
%\begin{verbatim}
%  \appendix
%\end{verbatim}
%and note that in the appendix, sections are lettered, not numbered. This document has two appendices, demonstrating the section and subsection identification method.


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
%\begin{acks}
%To Robert, for the bagels and explaining CMYK and color spaces.
%\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{../cryptobib/abbrev3,../cryptobib/crypto,ref}


%%
%% If your work has an appendix, this is the place to put it.
\appendix

%\input{correct.tex}
\section{Correctness of protocol $\Pi$} \label{proto-correctness}
In this section, we will show that the protocol specified in Section~\ref{proto-spec-spa} correctly computes the second highest bid value and identifies the highest bidder.
\begin{lemma}\label{lem-OR}
	In round $j$ of SPA, for $j\in [l]$, the computed bit $b_{sj}$ is the OR of contributed bits from all parties i.e.,  $b_{sj} = \lor_{i=1}^n d_{ij}$, for $i\in [n]$. Consequently, the computed bit is $\max_i(d_{ij})$, for $j\in [l]$.
\end{lemma}
\begin{proof}
	This follows directly from the property of encoding scheme (as described in Appendix~\ref{proto-abp}). If at least one of the parties $P_i$ has contributed $1$-bit code $B_{ij}$, the product $\prod_{i=1}^n B_{ij} \neq 1$ and thus computed output $b_{sj} = 1$. On the other hand, if $B_{ij}$ is $0$-bit code for all $i \in [n]$ then $\prod_{i=1}^n B_{ij} = 1$ and thus computed output $b_{sj} = 0$. Since the OR function outputs maximum of the input bits, computed bit is $\max_i(d_{ij})$, for $j\in [l]$.
\end{proof}
\begin{lemma}\label{lem-unique-winner}
	In the protocol specified in Section~\ref{proto-spec-spa}, there is exactly one party (denoted by $P_w$) that enters post winning phase, when all the parties follow the protocol honestly and have distinct bid values. 
\end{lemma}
\begin{proof}
	Suppose there is no $j\in[l]$ such that $j$ is the winning round for any party. Then, we have that for every $j$, it is not the case that exactly one party contributes 1-bit. Also, note that an honest party contributes $1$-bit only if they have not yet lost the auction. Now, Let us denote by $S_k$, the set of all parties who have not yet lost in the auction till round $k$. Then we have $|S_k|\geq |S_{k+1}|$, $\forall k\in[l-1]$. And we have, since no party has reached the post winning phase, $S_l\geq 2$. But this implies that all the parties in $S_l$ have the same bid, which is contrary to our assumption that no parties have same bids.\\
	Now suppose more than two parties reach the post winning phase. Then one of the following cases occur:
	\begin{itemize}
		\item Both parties reach post winning phase in same round: In the protocol, a party reaches the post winning phase only if it is the only party that contributes $1$-bit in the OT phase of that round. Hence, two parties cannot reach post winning phase in the same round.
		\item One party reaches post winning phase before other party: If one party reaches post winning phase, then it always contributes $1$ in the OT phase in all the subsequent rounds. Hence, after a party has reached the post winning phase, no other party can be the only party contributing $1$ in any subsequent rounds.
	\end{itemize}
\end{proof}
\begin{theorem} \label{thm-honest-bidder-correct} 
	The protocol specified in Section~\ref{proto-spec-spa} computes the second highest bid value correctly when all parties follow the protocol.
\end{theorem}
\begin{proof}
	From Lemma~\ref{lem-OR}, we have that the computed output during each round is the highest of bit contributed from the bidders. Moreover, recall that unique winner in the protocol writes the same bit codes to BB as that of second highest bidder. This prevents second highest bidder from assuming that it is the winner and also ensures that second highest bidder does not drop out of race all through the protocol. Thus, during every round the computed bit corresponds to that of second highest bid.
\end{proof}


\begin{theorem}
	The protocol specified in Section~\ref{proto-spec-spa} correctly identifies the highest bidder when all parties follow the protocol.
\end{theorem}

\begin{proof}
	From Lemma~\ref{lem-unique-winner} we have a unique winner in the protocol. During the winner discovery round, winner alone has a $1$ bit to contribute while every other party has a $0$ bit to contribute. Thus, winner's bid value is higher than all other bidders.
\end{proof}

%\input{app.tex}
\section{Proof of Theorem~\ref{thm-privacy-sim-rational}}
\label{app:privacy}
\paragraph{Ideal Functionality.}
We consider the ideal functionality $\calf$ to identify the winner and to compute second highest bid. The functionality $\calf$ operates with a set of parties $P = \{P_1,\ldots, P_n\}$ as follows:
\begin{itemize}
	\item Each party $P_i$ invokes $\calf$ with input $b_i$.
	\item Once all $n$ bids are available, $\calf$ computes:\\
	$w = \argmax_i(b_i)$ and $b_s = \max_{i \neq w}(b_i)$
	\item $\calf$ returns the tuple ($w, b_s$) to each party.
\end{itemize}  

\begin{theorem}[Theorem 5.6 restated]
	Assuming $\com$ is a secure commitment scheme, DDH assumption holds in group $\grp$, $\Pi_{OT}$ is a semi-honest secure OT protocol and zero knowledge property holds for the NIZKs, $\Pi$ specified in Section~\ref{proto-spec-spa} securely realizes the functionality $\calf$ in the presence of non-deviating parties.
\end{theorem}
\begin{proof}
	We will construct a simulator $\cals$ for a PPT semi-honest party $P_k$, such that 
	\[\view_k^{\Pi} \approx_c \cals^\calf_{P_k} \] 
	
	The simulator is invoked with public parameters $\mathsf{pp}$, and bid value $b_k$ of $P_k$. 
	
	\paragraph {Setup Phase}: 
	\begin{itemize}
		\item $\cals$ samples secret keys and randomness $x_{ij}, r_{ij} \smpl \zq$ on behalf of all parties $P_i, i \in [n]$. It samples OT sender randomness $\gamma_{ij,m} \in \sfr$ and OT receiver randomness $\beta_{ij,m} \in \sfr$ for all $P_i$ interacting with $P_m$ during round $j \in [l]$. Computes the public keys $X_{ij} = g^{x_{ij}}, \forall i \in [n]$.  
		
		\item $\cals$ generates the $0$-tokens $\omega_{ij,m}$ for each party $P_i$ interacting with party $P_m$, for rounds $1 \leq j \leq l$.
		
		\item $\cals$ generates the corresponding commitments to $0$-tokens:
		chooses $\delta_{ij,m} \smpl \zq, j \in [l]$, computes $\Omega_{ij,m} = g^{\omega_{ij,m}}h^{\delta_{ij,m}}$. 				
		
		\item For each party $P_i, i \neq k, i \neq s, i \neq w$: $\cals$ constructs commitments to bits of bid values of $0$:
		chooses $a_{ij} \smpl \zq, j \in [l]$, computes $c_{ij} = g^{0}h^{a_{ij}}$.
		
		\item $\cals$ invokes $\calf$ on behalf of $P_k$ with input $b_k$ to obtain $(w, b_s)$.
		
		\item  If $b_k \neq b_s$, one of the parties is designated as $P_s$. For this party, $\cals$ constructs commitments $c_{sj} = \com(b_{sj},a_{sj})$. Else commitments are constructed for bits of $b_k$.
		
		If $k \neq w$, $\cals$ chooses $\bar{j}$ to be the smallest value of $j$ such that $b_{sj} = 0, 1 \leq j \leq l$. $\cals$ chooses $b_w$ such that its first $\bar{j}-1$ bits are equal to corresponding bits of $b_s$, $b_{w\bar{j}}=1$ and remaining bits are all $0$.  $\cals$ computes bit commitments for party $P_w$ for bits $b_{wj}$ and party $P_k$ for bits $b_{kj}, j \in [l]$. \\ 	
		If $k = w$, $\cals$ computes bit commitments for party $P_k$ for bits  $b_{kj}, j \in [l]$. \\
		All commitments are written to BB.
	\end{itemize}
	\paragraph {Auction phase:} For this phase, we need to distinguish three cases.
	\begin{enumerate}
		\item $P_k$ is the winner :
		\begin{itemize}
			\item In this case, $b_w = b_k$. $\cals$ identifies the round $\bar{j}$  in which $b_w$ differs from $b_s$. 
			\item For $1 \leq j < \bar{j}$ and each $i \neq k$, $\cals$ invokes $\mathsf{OT.R}_1(b_{kj}, \beta_{kj,i})$ to obtain $\otr^{1}_{kj,i}$. For $\bar{j} \leq j \leq l$,  $\cals$ invokes $\mathsf{OT.R}_1(1, \beta_{kj,i})$ to obtain $\otr^{1}_{kj,i}$.
			
			\item For the party $P_s$, $1 \leq j \leq l$ and $i \neq s$, $\cals$  invokes $\mathsf{OT.R}_1(b_{sj}, \beta_{sj,i})$ to obtain $\otr^{1}_{sj,i}$.
			
			\item For all other parties $P_m$, for $1 \leq j \leq l$ and $i \neq m$, $\cals$ invokes $\mathsf{OT.R}_1(0, \beta_{mj,i})$ to obtain $\otr^{1}_{mj,i}$.\\
			All $\otr^{1}$ messages are written to BB.
			
			\item For the winner, $\cals$ generates $B_{wj}$ for the bits corresponding to $b_s$ for all rounds $1 \leq j \leq l$. $\cals$ generates bit codes $B_{sj}$ for the bits corresponding to $b_s$ for all rounds $1 \leq j \leq l$. For the remaining bidders, $\cals$ generates $0$-bit codes for all rounds. All bit codes are written to BB at the end of each round.
			
			
			\item For $P_w$, $\cals$  computes\\ $\mathsf{OT.S} (\otr^{1}_{ij,w}, g^{\omega_{wj,i}}, B_{wj}, \gamma_{wj,i})$ to obtain $\ots_{wj,i}$ for all parties $i \neq w$ and for $1 \leq j < \bar{j}$. For rounds $\bar{j} \leq j \leq l$, $\cals$ samples $M_{wj}' \smpl \grp$ and runs $\mathsf{OT.S} (\otr^{1}_{ij,w}, g^{\omega_{wj,i}},$ $M_{wj}', \gamma_{wj,i})$ to obtain $\ots_{wj,i}$ for all parties $i \neq w$.
			
			\item For $P_s$, using $\gamma_{sj,i}$, $\cals$  invokes $\mathsf{OT.S} (\otr^{1}_{ij,s}, g^{\omega_{sj,i}}, B_{sj}, \gamma_{sj,i})$ to obtain $\ots_{sj, i}$ for each OT receiver $P_i$.
			
			\item For $P_m$ where $m \neq w, m \neq s$, using $\gamma_{mj,i}$, $\cals$  runs $\mathsf{OT.S} (\otr^{1}_{ij,m},$ $g^{\omega_{mj,i}}, B_{mj}, \gamma_{mj,i})$ to obtain $\ots_{mj, i}$ for each OT receiver $P_{i}$.\\
			All $\ots$ messages are written to BB.
		\end{itemize}
		\item $P_k$ is the second highest bidder:
		\begin{itemize}
			\item In this case the input $b_k = b_s$. $\cals$ chooses $\bar{j}$ to be the smallest value of $j$ such that $b_{sj} = 0$.
			
			\item For $1 \leq j < \bar{j}$ and $i \neq w$, $\cals$ invokes $\mathsf{OT.R}_1(b_{sj}, \beta_{wj,i})$ to obtain $\otr^{1}_{wj,i}$ for OT sender $P_i$.
			For $\bar{j} \leq j \leq l$ and $i \neq w$, $\cals$ invokes $\mathsf{OT.R}_1(1, \beta_{wj,i})$ to obtain $\otr^{1}_{wj,i}$.
			
			\item For the party $P_k$, $1 \leq j \leq l$ and $i \neq s$, $\cals$  invokes $\mathsf{OT.R}_1(b_{sj}, \beta_{sj,i})$ to obtain $\otr^{1}_{sj,i}$.
			
			\item For all other parties $P_m$ $m \neq w, m \neq s$, for $1 \leq j \leq l$, $\cals$ invokes $\mathsf{OT.R}_1(0, \beta_{mj,i})$ to obtain $\otr^{1}_{mj,i}$. \\
			All $\otr^1$ messages are written to BB.
			
			\item For the winner $P_w$, $\cals$ generates $B_{wj}$ for the bits corresponding to $b_{sj}$ for all rounds. $\cals$ generates bit codes $B_{sj}$ for the bits corresponding to $b_s$ for all rounds. For the remaining bidders, $\cals$ generates $0$-bit codes for all rounds. All bit codes are written to BB at the end of each round. 
			
			\item For $P_w$, $\cals$  computes\\ $\mathsf{OT.S} (\otr^{1}_{ij,w}, g^{\omega_{wj,i}}, B_{wj}, \gamma_{wj,i})$ to obtain $\ots_{wj,i}$ for all parties $i \neq w$ and for $1 \leq j < \bar{j}$. For rounds $\bar{j} \leq j \leq l$, $\cals$ samples $M_{wj}' \smpl \grp$ and runs $\mathsf{OT.S} (\otr^{1}_{ij,w}, g^{\omega_{wj,i}},$ $M_{wj}', \gamma_{wj,i})$ to obtain $\ots_{wj,i}$ for all parties $i \neq w$.
			
			\item For $P_s$, $\cals$  invokes $\mathsf{OT.S} (\otr^{1}_{ij,s}, g^{\omega_{sj,i}}, B_{sj}, \gamma_{sj,i})$ to obtain $\ots_{sj, i}$ for each OT receiver $P_i, i \neq s$.
			
			\item For $P_m$ where $m \neq w, m \neq s$, $\cals$  runs $\mathsf{OT.S} (\otr^{1}_{ij,m}, g^{\omega_{mj,i}},$ $B_{mj}, \gamma_{mj,i})$ to obtain $\ots_{mj, i}$ for each OT receiver $P_{i}, i \neq m$.\\
			All $\ots$ messages are written to BB.
		\end{itemize}
		\item $P_k$ is neither winner nor second highest bidder.
		\begin{itemize}
			\item In this case $b_k \neq b_s, b_k \neq b_w$. $\cals$ chooses $\bar{j}$ to be the smallest value of $j$ such that $b_{sj} = 0, 1 \leq j \leq l$.
			
			\item $\cals$ compares the value $b_k$ with $b_s$ and identifies the round when $P_k$ would drop out of race and computes the values of $d_{kj}$ for $1 \leq j \leq l$.
			
			\item For $1 \leq j < \bar{j}$ and $i \neq w$, $\cals$ invokes $\mathsf{OT.R}_1(b_{sj}, \beta_{wj,i})$ to obtain $\otr^{1}_{wj,i}$. For $\bar{j} \leq j \leq l$ and $i \neq w$,  $\cals$ invokes $\mathsf{OT.R}_1(1, \beta_{wj,i})$ to obtain $\otr^{1}_{wj,i}$.
			
			\item For the party $P_s$, $1 \leq j \leq l$ and $i \neq s$, $\cals$ invokes $\mathsf{OT.R}_1(b_{sj}, \beta_{sj,i})$ to obtain $\otr^{1}_{sj,i}$.
			
			\item For the party $P_k$, $1 \leq j \leq l$ and $i \neq k$, $\cals$ invokes $\mathsf{OT.R}_1(d_{kj}, \beta_{kj,i})$ to obtain $\otr^{1}_{kj,i}$.
			
			\item For all other parties $P_m$ $m \neq w, m \neq s, m \neq k$, for $1 \leq j \leq l$ and for all other $P_i$, $\cals$ invokes $\mathsf{OT.R}_1(0, \beta_{mj,i})$ to obtain $\otr^{1}_{mj,i}$.\\
			All $\otr^1$ messages are written to BB. 
			
			\item For the winner $P_w$, $\cals$ generates $B_{wj}$ for the bits corresponding to $b_s$ for all rounds $1 \leq j \leq l$. $\cals$ generates bit codes $B_{sj}$ for the bits corresponding to $b_s$ for all rounds $1 \leq j \leq l$. Then $\cals$ generates bit codes $B_{kj}$ for the bits corresponding to $d_{kj}$ for all rounds $1 \leq j \leq l$. For the remaining bidders, $\cals$ generates $0$-bit codes for all rounds. All bit codes are written to BB at the end of each round.
			
			\item For $P_w$, using $\gamma_{wj,i}$ $\cals$  computes\\ $\mathsf{OT.S} (\otr^{1}_{ij,w}, g^{\omega_{wj,i}}, B_{wj}, \gamma_{wj,i})$ to obtain $\ots_{wj,i}$ for all parties $i \neq w$ and for $1 \leq j < \bar{j}$. For rounds $\bar{j} \leq j \leq l$, $\cals$ samples $M_{wj}' \smpl \grp$ and runs $\mathsf{OT.S} (\otr^{1}_{ij,w}, g^{\omega_{wj,i}},$ $M_{wj}', \gamma_{wj,i})$ to obtain $\ots_{wj,i}$ for all parties $i \neq w$.
			
			\item For $P_s$ using $\gamma_{sj,i}$, $\cals$  computes\\ $\mathsf{OT.S} (\otr^{1}_{ij,s}, g^{\omega_{sj,i}}, B_{sj}, \gamma_{sj,i})$ to obtain $\ots_{sj, i}$ for each OT receiver $P_i$. 
			
			\item For $P_k$ using $\gamma_{kj,i}$, $\cals$  computes\\ $\mathsf{OT.S} (\otr^{1}_{ij,k}, g^{\omega_{kj,i}}, B_{kj}, \gamma_{kj,i})$ to obtain $\ots_{kj, i}$ for each OT receiver $P_i$.
			
			\item For $P_m$ where $m \neq w, m \neq s, m \neq k$ using $\gamma_{mj,i}$, $\cals$  runs $\mathsf{OT.S} (\otr^{1}_{ij,m}, g^{\omega_{mj,i}}, B_{ij}, \gamma_{mj,i})$ to obtain $\ots_{mj, i}$ for each OT receiver $P_{i}$.\\
			All $\ots$ messages are written to BB.
		\end{itemize}
	\end{enumerate}
	For each of the above cases, during  {\bf Verification Phase}, $\cals$ does the following:
	\begin{itemize}
		\item $\cals$ generates NIZK proofs for all losing parties for the decider rounds as per their bid values and writes to BB.
		
		\item $\cals$ opens the private keys $x_{wj}, r_{wj}$ used for encoding the bit codes of winner $P_w$ for all rounds, $1 \leq j \leq l$ and writes them to BB.
		
		\item $\cals$ provides the $0$-tokens on behalf of all losing parties for the rounds when computed output is $0$, and writes them to BB. Corresponding $0$-token commitments for each party are also opened onto BB.
	\end{itemize}
	
	In order to argue indistinguishability, we consider following hybrids.  
	
	
	\begin{itemize}
		\item $H_0$: This is the real run of the protocol where parties generate actual public keys, bit commitments to the bits of their bid values, bit codes corresponding to their bid values, $0$-tokens and their commitments, NIZK proofs and generate OT messages as per their contributed bits for the round.
		
		\item $H_1$: This is same as $H_0$ except for following. In the verification phase, NIZK proofs are replaced with simulated proofs by invoking the Zero Knowledge simulator that is guaranteed by the NIZK construction. \\
		By the zero knowledge property of NIZK proofs, $H_1$ is indistinguishable from $H_0$ for all PPT distinguishers.
		
		\item $H_2$: This is same as $H_1$ except for following. During auction phase,  $\beta_{ij,m} \in \sfr$ are sampled for each party $P_i$ acting as OT receiver while interacting with OT sender $P_m$ where $i \neq k, i \neq s, i \neq w$.  $\mathsf{OT.R}_1(0, \beta_{ij,m})$ is used to compute $\otr^{1}_{ij,m}$ and written to BB. \\
		By receiver security of $\Pi_{OT}$, $H_2$ is indistinguishable from $H_1$ for all PPT distinguishers.
		
		\item $H_3$: This is same as $H_2$ except for following. During auction phase, for each OT sender $P_i$ interacting with OT receiver $P_m$, $\mathsf{OT.S} (\otr^{1}_{mj,i}, g^{\omega_{ij,m}}, B_{ij}, \gamma_{ij,m})$ is invoked with $B_{ij}$ being $0$-bit code, to compute $\ots_{ij,m}$ for all parties $i \neq k, i \neq s, i \neq w$ and for $1 \leq j < l$ and written to BB. Moreover, at the end of the round same $0$-bit codes $B_{ij}$ are written to the BB.\\
		By security of the bit encoding scheme, $H_3$ is indistinguishable from $H_2$ for all PPT distinguishers. 
		
		
		\item $H_4$: This is same as $H_3$ except for following. During setup phase, commitments are for $0$-bits for all parties $P_i, i \neq k, i \neq s, i \neq w$ and written to BB. \\
		By hiding property of the commitment scheme $\com$, $H_4$ is indistinguishable from $H_3$ for all PPT distinguishers.
		
	\end{itemize}
	Observe that the hybrid $H_4$ does not have any information about the bid values of parties other than $P_k$ and $P_s$. Thus $P_k$ cannot learn anything about losing bid values in $H_4$. Also, in $H_0$, view of $P_k$ corresponds to the real run whereas $H_4$ corresponds to $\cals$'s output. Moreover, by transitivity, $H_0 \approx_c H_4$. Thus it follows that,  
	\[\view_k^{\Pi} \approx_c \cals_{P_k}^\calf \]
\end{proof}

\section{Collusion resistance} Parties collude in a protocol to achieve certain objective -- typically to enhance their utility or for gaining some information about the other parties' inputs. We define a notion of collusion where parties do not like to collude if it affects their privacy.

\begin{definition} [Special collusion resistance]
    A protocol $\Pi$ among rational PPT parties $P_1, \ldots, P_n$ is said to be \emph{Special collusion resistant} if for all $i$ it holds that $P_i$ does not form collusion with any other $P_j, j \neq i$, if the collusion incurs loss of privacy for $P_i$.
\end{definition}

\begin{lemma}
    Assuming $\com$ is a secure commitment scheme, DDH assumption holds in group $\grp$, $\Pi_{OT}$ is a semi-honest secure OT protocol and zero knowledge property holds for the NIZKs, $\Pi$ specified in Section~\ref{proto-spec-spa} is special collusion resistant.
\end{lemma}

\begin{proof}
    We would like to make following observation. While several possible collusions can be formed, the collusion that is most effective involves first two highest bidders. With any other collusion, the auction outcome would be same as the one without collusion. We will consider following cases:
    \begin{enumerate}
        \item \emph{Ex-ante collusion} The collusion is formed, \emph{before} the protocol begins. In this case, motivation for the collusion is to enhance the utility of the winner by reducing the payment to auctioneer. Hence there is no incentive for second highest bidder to participate in the auction -- since that would reduce the utility for winner. Thus the protocol starts with no collusion.

        \item \emph{Ex-interim/Ex-post collusion} In this case, the collusion is either during or after the protocol execution. In both cases, the motive for the first two bidders is no longer about enhancing the utility, but for learning other parties' bids. This can be accomplished by pooling in the the encoded bits from other parties, share the encoding of $0$-bit with each other and run private computation. This computation reveals the position at which the third highest bidder would have dropped out -- thus revealing first few bits of third highest bidder. \\
        However, notice that such a computation requires the two highest bidders to share their $0$-bit encoding for each round. Thus, privacy is lost. Since we have assumed that rational parties do not like to lose their privacy -- even to gain information on other parties' bids, such a collusion does not manifest.
    \end{enumerate}
\end{proof}

\section{Contract Functionality}\label{app-contract}
Our protocol uses security deposits from the bidders to ensure honest behavior. Any deviation from a bidder that affects the protocol described in Section~\ref{proto-spec-spa} results in the forfeiture of the security deposit which is redistributed among the honest parties. A contract can be used for managing these transactions involving security deposits. Such a functionality can be realized as a contract within a legal framework using fiat currency or if the protocol uses block-chain as the bulletin board (BB), then smart contract with native currency of block-chain can be used.

\section{Anonymous Bidding Protocol} \label{proto-abp}
We use the \emph{Anonymous Bidding Protocol} (ABP) to compute the highest bid value which is a variation of the Anonymous Veto Protocol (AVP) first described in~\cite{avp06} and later used in~\cite{seal19,fast21,gks22}. 

ABP runs for $l$ rounds -- where $l$ is the number of bits in the binary representation of the bid values. The protocol proceeds as below:
\begin{itemize}
	\item Let $P_i$'s bid $b_i = (b_{i1} || \ldots ||b_{il})$.
	\item $P_i$ participates in $j$th round of ABP by contributing $b_{ij}$. This continues until $P_i$ keeps contributing a bit equal to the computed output for the round. If in a round, there is other bidder who contributes a $1$ while the $P_i$ has $0$, $P_i$ drops out of the race at the end of that round.
	
	\item A party who has dropped out of the race, continues to participate in the protocol but only contributes a $0$ for all remaining rounds.
	
	\item Any round $1 \leq j \leq l$ which has at least one bidder bidding a $1$ bit is considered as the \textit{decider round}. 
	
	\item Thus, a bidder $P_i$ uses the bid $d_{ij}$ during round $j$ as
	\[d_{ij} = \begin{cases}
		0, &\text{if $P_i$ is not in race} \\
		&\text{ or $P_i$ bid 0 in any of previous decider rounds. }\\
		b_{ij}, &\text{if $P_i$ is in the race}\\
		&\text{ or $P_i$ bid 1 in all previous decider rounds.}
	\end{cases}\]
	
	\item Logical OR of all individual bids used in $j$th round is evaluated to be the $j$th computed bit. i.e.,
	\[b_{sj} = \bigvee_{i=1}^n d_{ij}\]
	
	\item Protocol's output bid $b_s$ is computed as $b_s = b_{s1} || \cdots || b_{sl}$
\end{itemize}

In order to ensure the privacy of the bits used during computation, the contribution bits are encoded such that no PPT party can distinguish between the encoding of $0$ and encoding of $1$. There can be several possible encodings for representing the bits. For example, parties can use secret share of $0$ to represent $0$-bit encoding and secret share of any non-zero number to represent $1$-bit encoding. The reconstructed value would represent the encoding of computed bit. Notice that this scheme does indeed satisfy the requirements of ABP computation described above.\\ 

However, we use the encoding scheme adopted from \cite{fast21}. For this, we make use of a group $\grp$ of prime order $q$ where DDH assumption holds. Let $g \in \grp$ be a publicly known generator. The encoding and corresponding computation on the coded bits are performed as follows:

\begin{enumerate}
	
	\item Each bidder $P_i$, $i \in [n]$ allocates private keys $x_{ij}, r_{ij} \smpl \mathbb{Z}_q$, $i \in [n], j \in [l]$. Public keys $X_{ij}  = g^{x_{ij}}$ are published to the bulletin board.
	
	\item Once public keys from all bidders are available, each bidder computes:
	$$Y_{ij} = 
	\dfrac{\prod_{k=1}^{i-1} X_{kj}}{\prod_{k=i+1}^n X_{kj} } $$
	
	
	\item Each \emph{contributed} bit  $d_{ij}$  is encoded as : \\
	$B_{ij} =  
	\begin{cases}
		\text{0-bit code}:\quad Y_{ij}^{x_{ij}} 	&\text{if}\quad d_{ij} = 0\\
		\text{1-bit code}:\quad g^{r_{ij}}	&\text{if}\quad d_{ij} = 1
	\end{cases}$
	
	
	\item The $j$th computed bit is evaluated as the logical-OR of individual bidding bits $b_{ij}$ for the $j$th position: $b_{sj} = \bigvee_{i=1}^n b_{ij}$. This is computed  using the encoded bits as follows:\\
	$b_{sj} =\begin{cases}
		0, \quad \text{if} \quad \prod_{i=1}^n B_{ij} = 1\\
		1, \quad \text{if} \quad \prod_{i=1}^n B_{ij} \neq 1
	\end{cases}$
\end{enumerate}
It follows from the DDH assumption holding in the group $\grp$ that the distributions of $0$-bit code and $1$-bit code are computationally indistinguishable.\\



\section{NIZK Proofs}\label{app-nizk}
This section describes the NIZK proof for losing parties. This proof is used to prove that a party has correctly computed the bit code written on to BB during every decider round $j$. For the construction of these NIZKs, we assume that \emph{Pedersen Commitment scheme}~\cite{C:Pedersen91} is used in the protocol. Each losing bidder $P_i$ needs to prove the following for $j$th iteration:

\begin{itemize}
	\item Proof of commitment: $c_{ij} = \com(b_{ij}, a_{ij}) = g^{b_{ij}}h^{a_{ij}}$
	\item Proof of knowledge of secret keys used for computation: $B_{ij} = Y_{ij}^{x_{ij}}$ for the $0$-bit code and $B_{ij} = g^{r_{ij}}$ for the $1$-bit code.
	\item Proof of knowledge of secret key used for computation during the previous decider round $\bar{j}$, $B_{i\bar{j}} = Y_{i\bar{j}}^{x_{i\bar{j}}}$  for the $0$-bit code or $B_{i\bar{j}} = g^{r_{i\bar{j}}}$ for the $1$-bit code. Along with this, knowledge of actual secret keys used for computation during iterations $\bar{j},j$  also need to be proved.
\end{itemize}

Thus, the relation that is established by this NIZK is:

\begin{equation}\label{rel-not-win}
	\calr =  \left\{ 
	\begin{split}
		b_{ij}, a_{ij}, \\ 
		x_{ij}, r_{i\bar{j}},\\
		r_{ij}, x_{i\bar{j}}
	\end{split} \; \Bigg\vert \;
	\begin{split}
		\left.\left(\frac{c_{ij}}{g} = h^{a_{ij}} \land B_{i\bar{j}} = g^{r_{i\bar{j}}} \land B_{ij} = g^{r_{ij}}\right)\right.\bigvee\\
		\left.\left(c_{ij} = h^{a_{ij}} \land B_{ij} = Y_{ij}^{x_{ij}} \land X_{ij} = g^{x_{ij}}\right) \right. \bigvee \\
		\left(
		\begin{split}
			\frac{c_{ij}}{g} = h^{a_{ij}} \land B_{i\bar{j}} = Y_{i\bar{j}}^{x_{i\bar{j}}} \land X_{i\bar{j}} = g^{x_{i\bar{j}}}  
			\land\\ 
			B_{ij} = Y_{ij}^{x_{ij}} \land X_{ij} = g^{x_{ij}}
		\end{split}		\right)  
	\end{split}
	\right\}	
\end{equation}

We use the approach in~\cite{cs97,fast21} for constructing NIZK for the above relation. 
This is accomplished by representing the relation in terms of the following clauses:
\[\begin{split}
	F_1 = &DL(h, c_{ij}) \otimes \left[DL(Y_{ij}, B_{ij}) \cap DL(g,X_{ij})\right]\\
	F_2 = &DL(h, c_{ij}/g) \otimes DL(g, B_{i\bar{j}}) \otimes DL(g, B_{ij})\\
	F_3 = &DL(h, c_{ij}/g) \otimes \left[ DL(Y_{i\bar{j}}) \cap DL(g, X_{i\bar{j}})\right] \otimes \\
	&\left[DL(Y_{ij}, B_{ij}) \cap DL(g,X_{ij})\right]
\end{split}\]
Thus, the proofs need to be constructed for $F = F_1 \cup F_2 \cup F_3$.\\

To prove the knowledge of either $F_1$ or $F_2$ or $F_3$, assuming that $F_k$ is known, party $P_i$ proceeds as follows:
\begin{enumerate}
	\item Choose $v_0, v_1, v_2, v_3, v_4, v_5, v_6, v_7 \smpl \mathbb{Z}_q$.
	\item Choose $(w_0, w_1, w_2)$ with $w_k = 0$ and $w_i \smpl \mathbb{Z}_q$ for $i \neq k$.
	\item Compute the commitment tokens: 
	\begin{itemize}
		\item $t_0 = c_{ij}^{w_0}h^{v_0}$, \quad
		$t_1 = B_{ij}^{w_0}Y_{ij}^{v_1}$, \quad
		$t_2 = X_{ij}^{w_0}g^{v_1}$
		\item $t_3 = \left(\dfrac{c_{ij}}{g}\right)^{w_1}h^{v_2}$, \quad
		$t_4 = B_{i\bar{j}}^{w_1}g^{v_3}$, \quad
		$t_5 = B_{ij}^{w_1}g^{v_4}$, 
		\item $t_6 = \left(\dfrac{c_{ij}}{g}\right)^{w_2}h^{v_5}$, \quad
		$t_7 = B_{i\bar{j}}^{w_2}Y_{i\bar{j}}^{v_6}$,
		\item $t_8 = X_{i\bar{j}}^{w_2}g^{v_6}$, \quad
		$t_{9} = B_{ij}^{w_2}Y_{ij}^{v_7}$, \quad
		$t_{10} = X_{ij}^{w_2}g^{v_7}$
	\end{itemize}
	
	\item Compute the random challenge using the public hash function as: $$H = \calh\left(\substack{h, c_{ij}, Y_{ij}, B_{ij},g, X_{ij}, \dfrac{c_{ij}}{g}, B_{i\bar{j}}, Y_{i\bar{j}}, X_{i\bar{j}},\\ t_0, t_1, t_2, t_3, t_4, t_5, t_6, t_7, t_8, t_9, t_{10}} \right) \mod q$$
	
	\item Compute $(\gamma_0, \gamma_1, \gamma_2)$ as:
	\[\gamma_i = 
	\begin{cases}
		H - (w_0 + w_1 + w_2) \mod q, \quad &\text{if $i = k$}	\\
		w_i, \quad &\text{otherwise}
	\end{cases}\]
	
	\item Set:\\
	$(u_0, u_1, u_2, u_3, u_4, u_5, u_6, u_7) = 
	\begin{cases}
		(a_{ij}, x_{ij}, 0,0,0,0,0,0), \; k = 1	\\
		(0,0, a_{ij}, r_{i\bar{j}}, r_{ij},0,0,0), \; k = 2 \\
		(0,0,0,0,0, a_{ij}, x_{i\bar{j}}, x_{ij}), \; k = 3 
	\end{cases}$
	
	\item Compute responses $R = (s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9, s_{10})$ as (all operations are modulo $q$):
	\begin{itemize}
		\item $s_0 = v_0 - \gamma_k u_0$
		\item $s_1 = s_2 = v_1 - \gamma_k u_1$
		\item $s_3 = v_2 - \gamma_k u_2$
		\item $s_4 = v_3 - \gamma_k u_3$
		\item $s_5 = v_4 - \gamma_k u_4$
		\item $s_6 = v_5 - \gamma_k u_5$
		\item $s_7 = s_8 = v_6 - \gamma_k u_6$		
		\item $s_{9} = s_{10} = v_7 - \gamma_k u_7$
		
	\end{itemize}
	
	\item Publish the proof as:\\ $\pi = (\gamma_0, \gamma_1, \gamma_2, s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9, s_{10})$. 
	
	\item Proof validity can be checked by reconstructing the commitments:
	\begin{itemize}
		\item $t_0' = c_{ij}^{\gamma_0} h^{s_0}$,\quad \quad \quad
		$t_1' = B_{ij}^{\gamma_0} Y_{ij}^{s_1}$, \quad
		$t_2' = X_{ij}^{\gamma_0} g^{s_2}$
		\item $t_3' = (c_{ij}/g)^{\gamma_1} h^{s_3}$, \quad 
		$t_4' = B_{i\bar{j}}^{\gamma_1}g^{s_4}$, \quad
		$t_5' = B_{ij}^{\gamma_1} g^{s_5}$
		\item $t_6' = (c_{ij}/g)^{\gamma_2} h^{s_6}$, \quad
		$t_7' = B_{i\bar{j}}^{\gamma_2}Y_{i\bar{j}}^{s_7}$
		\item $t_8' = X_{i\bar{j}}^{\gamma_2} g^{s_8}$, \quad \quad
		$t_{9}' = B_{ij}^{\gamma_2} Y_{ij}^{s_{9}}$, \quad
		$t_{10}' = X_{ij}^{\gamma_2} g^{s_{10}}$	
	\end{itemize}
	\item Evaluate:
	\begin{align*}
		H' = \calh\left(\substack{
			h, c_{ij}, Y_{ij}, B_{ij},g, X_{ij}, \dfrac{c_{ij}}{g}, 
			B_{i\bar{j}}, Y_{i\bar{j}}, X_{i\bar{j}}, \\
			t_0', t_1', t_2', t_3', t_4', t_5', t_6', t_7', t_8', t_9', t_{10}'}
		\right)\mod q
	\end{align*}
	\item Then check for following condition:
	\[\gamma_0 + \gamma_1 + \gamma_2 \overset{?}{=} H'\]
	\item Accept if the check passes.
\end{enumerate}
\section{Secure computation of stateful functions} 
The secure computation is challenging in itself. It gets more involved when we consider sateful functions. 
\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.